---
import conceptosData from "../../public/conceptos.json";
---

<div class="relative py-24 px-6 bg-white overflow-hidden" id="match-expert">
    <!-- Decorative Mesh -->
    <div
        class="absolute inset-0 bg-[radial-gradient(#e5e7eb_1px,transparent_1px)] [background-size:32px_32px] [mask-image:radial-gradient(ellipse_50%_50%_at_50%_50%,#000_70%,transparent_100%)] opacity-30"
    >
    </div>

    <div class="max-w-6xl mx-auto relative z-10">
        <header class="text-center mb-20">
            <span
                class="inline-block px-4 py-1.5 bg-indigo-50 text-indigo-600 rounded-full text-[10px] font-black uppercase tracking-[0.2em] mb-4"
            >
                Test de Correlación
            </span>
            <h2
                class="text-5xl md:text-6xl font-black text-slate-900 tracking-tighter mb-6"
            >
                Relación <span class="italic text-indigo-600">Conceptual</span>
            </h2>
            <p
                class="text-slate-500 font-medium max-w-xl mx-auto leading-relaxed"
            >
                Demuestra tu dominio técnico conectando cada término con su
                definición operativa. El éxito requiere precisión estratégica.
            </p>
        </header>

        <div
            class="grid grid-cols-1 md:grid-cols-2 gap-12 lg:gap-24 relative"
            id="match-arena"
        >
            <!-- Terms -->
            <div class="space-y-6" id="terms-col">
                <h3
                    class="text-xs font-black text-slate-400 uppercase tracking-widest mb-10 pl-4 border-l-4 border-indigo-500"
                >
                    Término Estratégico
                </h3>
                <!-- JS Populated -->
            </div>

            <!-- Definitions -->
            <div class="space-y-6" id="defs-col">
                <h3
                    class="text-xs font-black text-slate-400 uppercase tracking-widest mb-10 pl-4 border-l-4 border-emerald-500"
                >
                    Definición Operativa
                </h3>
                <!-- JS Populated -->
            </div>

            <!-- SVG Overlay -->
            <svg
                id="match-svg"
                class="absolute inset-0 w-full h-full pointer-events-none z-0 overflow-visible"
            ></svg>
        </div>

        <div class="mt-20 flex flex-col items-center gap-6">
            <div
                class="px-6 py-2 bg-slate-50 rounded-full border border-slate-100 text-slate-400 font-bold text-[10px] tracking-[0.3em] uppercase"
            >
                Progreso: <span id="match-score" class="text-indigo-600"
                    >0/5</span
                >
            </div>

            <button
                id="reset-match"
                class="px-12 py-5 bg-slate-900 hover:bg-black text-white rounded-[2rem] font-black text-sm transition-all shadow-2xl shadow-slate-900/20 active:scale-95 group flex items-center gap-4"
            >
                <svg
                    class="w-5 h-5 group-hover:rotate-180 transition-transform duration-500"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2.5"
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                    ></path>
                </svg>
                REINICIAR DESAFÍO
            </button>
        </div>
    </div>
</div>

<style>
    .match-item {
        background: white;
        border: 2px solid #f1f5f9;
        padding: 1.5rem 2rem;
        border-radius: 1.5rem;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        font-weight: 700;
        color: #1e293b;
        position: relative;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 6rem;
        text-align: center;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.02);
    }

    .match-item:hover:not(.matched):not(.sel) {
        border-color: #6366f1;
        background: #f8fafc;
        transform: translateX(4px);
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.05);
    }

    .def-item:hover:not(.matched):not(.sel) {
        transform: translateX(-4px);
    }

    .match-item.sel {
        background: #1e293b;
        color: white;
        border-color: #1e293b;
        box-shadow: 0 10px 30px rgba(30, 41, 59, 0.2);
        transform: scale(1.05);
    }

    .match-item.matched {
        background: #f0fdf4;
        border-color: #10b981;
        color: #065f46;
        cursor: default;
        opacity: 0.7;
    }

    .match-item.error {
        animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
        border-color: #ef4444;
        background: #fef2f2;
        color: #991b1b;
    }

    @keyframes shake {
        0%,
        100% {
            transform: translateX(0);
        }
        20%,
        60% {
            transform: translateX(-4px);
        }
        40%,
        80% {
            transform: translateX(4px);
        }
    }

    .match-line {
        stroke: #6366f1;
        stroke-width: 4px;
        stroke-linecap: round;
        stroke-dasharray: 1000;
        stroke-dashoffset: 1000;
        animation: drawLine 0.8s forwards cubic-bezier(0.4, 0, 0.2, 1);
        filter: drop-shadow(0 0 8px rgba(99, 102, 241, 0.3));
    }

    @keyframes drawLine {
        to {
            stroke-dashoffset: 0;
        }
    }
</style>

<script define:vars={{ conceptosData }}>
    let selT = null;
    let selD = null;
    let score = 0;
    const TOTAL = 5;

    const tCol = document.getElementById("terms-col");
    const dCol = document.getElementById("defs-col");
    const resetB = document.getElementById("reset-match");
    const scB = document.getElementById("match-score");
    const svgE = document.getElementById("match-svg");

    function init() {
        // Cleanup old cards (careful with headers)
        tCol.querySelectorAll(".match-item").forEach((e) => e.remove());
        dCol.querySelectorAll(".match-item").forEach((e) => e.remove());
        svgE.innerHTML = "";
        selT = null;
        selD = null;
        score = 0;
        scB.textContent = `0/${TOTAL}`;

        const pool = conceptosData
            .sort(() => 0.5 - Math.random())
            .slice(0, TOTAL);
        const terms = [...pool]
            .map((p) => ({ id: p.termino, val: p.termino }))
            .sort(() => 0.5 - Math.random());
        const defs = [...pool]
            .map((p) => ({ id: p.termino, val: p.definicion }))
            .sort(() => 0.5 - Math.random());

        terms.forEach((t) => {
            const el = document.createElement("div");
            el.className = "match-item";
            el.textContent = t.val;
            el.dataset.id = t.id;
            el.onclick = () => {
                if (el.classList.contains("matched") || el === selT) return;
                if (selT) selT.classList.remove("sel");
                selT = el;
                el.classList.add("sel");
                check();
            };
            tCol.appendChild(el);
        });

        defs.forEach((d) => {
            const el = document.createElement("div");
            el.className =
                "match-item def-item text-sm font-medium italic leading-relaxed px-6";
            el.textContent = d.val;
            el.dataset.id = d.id;
            el.onclick = () => {
                if (el.classList.contains("matched") || el === selD) return;
                if (selD) selD.classList.remove("sel");
                selD = el;
                el.classList.add("sel");
                check();
            };
            dCol.appendChild(el);
        });
    }

    function check() {
        if (selT && selD) {
            if (selT.dataset.id === selD.dataset.id) {
                selT.classList.replace("sel", "matched");
                selD.classList.replace("sel", "matched");
                draw(selT, selD);
                selT = null;
                selD = null;
                score++;
                scB.textContent = `${score}/${TOTAL}`;
                if (score === TOTAL)
                    setTimeout(
                        () =>
                            alert(
                                "¡IMPECABLE! Has completado el test de correlación con éxito.",
                            ),
                        400,
                    );
            } else {
                const a = selT;
                const b = selD;
                a.classList.add("error");
                b.classList.add("error");
                setTimeout(() => {
                    a.classList.remove("error", "sel");
                    b.classList.remove("error", "sel");
                }, 500);
                selT = null;
                selD = null;
            }
        }
    }

    function draw(e1, e2) {
        const r1 = e1.getBoundingClientRect();
        const r2 = e2.getBoundingClientRect();
        const arena = document
            .getElementById("match-arena")
            .getBoundingClientRect();

        const x1 = r1.right - arena.left;
        const y1 = r1.top + r1.height / 2 - arena.top;
        const x2 = r2.left - arena.left;
        const y2 = r2.top + r2.height / 2 - arena.top;

        const L = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line",
        );
        L.setAttribute("x1", x1);
        L.setAttribute("y1", y1);
        L.setAttribute("x2", x2);
        L.setAttribute("y2", y2);
        L.setAttribute("class", "match-line");
        svgE.appendChild(L);
    }

    resetB.onclick = init;
    init();

    // Responsive lines logic (optional but good)
    window.onresize = () => {
        svgE.innerHTML = "";
        score = 0;
        init();
    };
</script>
