---
import conceptosData from "../../public/conceptos.json";
---

<div
    class="relative py-24 px-6 bg-slate-50 overflow-hidden"
    id="crucigrama-expert"
>
    <div class="max-w-7xl mx-auto">
        <div class="flex flex-col lg:flex-row gap-16 items-start">
            <!-- Header & Clues -->
            <div class="lg:w-1/3 sticky top-32">
                <header class="mb-12">
                    <span
                        class="inline-block px-4 py-1.5 bg-emerald-100 text-emerald-700 rounded-xl text-[10px] font-black uppercase tracking-widest mb-4"
                    >
                        Desaf√≠o de L√≥gica
                    </span>
                    <h2
                        class="text-5xl font-black text-slate-900 tracking-tighter mb-6 leading-none"
                    >
                        Crucigrama <span class="text-emerald-600">T√©cnico</span>
                    </h2>
                    <p class="text-slate-500 font-medium leading-relaxed">
                        Resuelve el crucigrama utilizando las definiciones de
                        los conceptos estrat√©gicos de Recursos Humanos.
                    </p>
                </header>

                <div class="space-y-8">
                    <div
                        class="bg-white/50 p-6 rounded-2xl border border-white shadow-sm"
                    >
                        <label
                            class="block text-[10px] font-black uppercase tracking-widest text-slate-400 mb-3"
                            >Cantidad de Palabras</label
                        >
                        <div class="flex gap-2" id="word-count-selector">
                            <button
                                data-count="8"
                                class="flex-1 py-2 rounded-xl border-2 border-slate-100 text-xs font-bold transition-all hover:bg-slate-50 data-[active=true]:border-emerald-500 data-[active=true]:bg-emerald-50 data-[active=true]:text-emerald-700"
                                >8</button
                            >
                            <button
                                data-count="10"
                                class="flex-1 py-2 rounded-xl border-2 border-slate-100 text-xs font-bold transition-all hover:bg-slate-50 data-[active=true]:border-emerald-500 data-[active=true]:bg-emerald-50 data-[active=true]:text-emerald-700"
                                >10</button
                            >
                            <button
                                data-count="12"
                                class="flex-1 py-2 rounded-xl border-2 border-slate-100 text-xs font-bold transition-all hover:bg-slate-50 data-[active=true]:border-emerald-500 data-[active=true]:bg-emerald-50 data-[active=true]:text-emerald-700"
                                >12</button
                            >
                            <button
                                data-count="15"
                                class="flex-1 py-2 rounded-xl border-2 border-slate-100 text-xs font-bold transition-all hover:bg-slate-50 data-[active=true]:border-emerald-500 data-[active=true]:bg-emerald-50 data-[active=true]:text-emerald-700"
                                >15</button
                            >
                        </div>
                    </div>

                    <div class="flex items-center justify-between px-4">
                        <span
                            id="timer-badge-cw"
                            class="px-3 py-1 bg-emerald-50 text-emerald-600 rounded-lg font-mono font-bold tracking-tighter"
                            >00:00</span
                        >
                        <div class="flex gap-1" id="cw-progress-dots"></div>
                    </div>

                    <div
                        class="max-h-[300px] overflow-y-auto pr-2 custom-scrollbar"
                    >
                        <h3
                            class="text-xs font-black text-slate-400 uppercase tracking-[0.2em] mb-4 flex items-center gap-2"
                        >
                            <span class="w-2 h-2 bg-emerald-500 rounded-full"
                            ></span> Horizontales
                        </h3>
                        <ul
                            id="clues-across"
                            class="space-y-3 text-sm font-medium text-slate-600"
                        >
                        </ul>

                        <h3
                            class="text-xs font-black text-slate-400 uppercase tracking-[0.2em] mt-8 mb-4 flex items-center gap-2"
                        >
                            <span class="w-2 h-2 bg-blue-500 rounded-full"
                            ></span> Verticales
                        </h3>
                        <ul
                            id="clues-down"
                            class="space-y-3 text-sm font-medium text-slate-600"
                        >
                        </ul>
                    </div>
                </div>

                <button
                    id="reset-crossword"
                    class="mt-12 w-full py-5 bg-slate-900 hover:bg-black text-white rounded-2xl font-black text-sm transition-all shadow-xl shadow-slate-900/20 active:scale-95 group flex items-center justify-center gap-3"
                >
                    REGENERAR CRUCIGRAMA
                </button>
            </div>

            <!-- Grid -->
            <div class="lg:w-2/3 w-full">
                <div class="relative group select-none">
                    <!-- Victory Modal Overlay -->
                    <div
                        id="victory-modal-cw"
                        class="absolute inset-0 z-50 bg-slate-900/40 backdrop-blur-xl flex items-center justify-center opacity-0 pointer-events-none transition-all duration-500 rounded-[3rem]"
                    >
                        <div
                            class="bg-white p-12 rounded-[2.5rem] shadow-2xl text-center transform scale-90 transition-transform duration-500 max-w-sm mx-auto"
                        >
                            <div
                                class="w-24 h-24 bg-emerald-100/50 rounded-full flex items-center justify-center mx-auto mb-8 text-4xl animate-bounce"
                            >
                                üí°
                            </div>
                            <h4
                                class="text-3xl font-black text-slate-900 mb-4 tracking-tighter"
                            >
                                ¬°MAGN√çFICO!
                            </h4>
                            <p class="text-slate-500 font-medium mb-8">
                                Has resuelto el crucigrama en <span
                                    id="finish-time-cw"
                                    class="text-emerald-600 font-bold"
                                    >00:00</span
                                >.
                            </p>
                            <button
                                id="close-modal-cw"
                                class="w-full py-5 bg-emerald-600 hover:bg-emerald-700 text-white rounded-2xl font-black text-sm transition-all shadow-xl shadow-emerald-900/20"
                                >CONTINUAR APRENDIENDO</button
                            >
                        </div>
                    </div>

                    <div
                        id="crossword-grid"
                        class="bg-white p-4 md:p-8 rounded-[3rem] border-8 border-white shadow-[0_20px_50px_rgba(0,0,0,0.03)] grid gap-1 overflow-auto max-h-[700px] justify-center content-center min-h-[500px] relative"
                    >
                        <!-- Floating Tooltip -->
                        <div
                            id="cw-tooltip"
                            class="absolute z-[60] bg-slate-900 text-white p-4 rounded-2xl shadow-2xl text-xs font-medium max-w-[200px] opacity-0 pointer-events-none transition-all duration-300 -translate-y-2"
                        >
                            <!-- JS Populated -->
                            <div
                                class="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-full w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-t-[6px] border-t-slate-900"
                            >
                            </div>
                        </div>
                        <!-- JS Populated Grid -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style is:global>
    .cw-cell {
        width: 35px;
        height: 35px;
        background: #f1f5f9;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: all 0.2s;
    }
    @media (min-width: 768px) {
        .cw-cell {
            width: 45px;
            height: 45px;
            border-radius: 8px;
        }
    }
    .cw-cell.active {
        background: white;
        border: 2px solid #e2e8f0;
        cursor: text;
    }
    .cw-cell.active:hover {
        border-color: #10b981;
    }
    .cw-cell.focused {
        border-color: #10b981 !important;
        box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
        z-index: 10;
    }
    .cw-cell .num {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 8px;
        font-weight: 900;
        color: #94a3b8;
        pointer-events: none;
    }
    @media (min-width: 768px) {
        .cw-cell .num {
            font-size: 9px;
        }
    }
    .cw-cell input {
        width: 100%;
        height: 100%;
        border: none;
        background: transparent;
        text-align: center;
        font-family: "Outfit", sans-serif;
        font-weight: 800;
        font-size: 1rem;
        text-transform: uppercase;
        color: #1e293b;
        outline: none;
    }
    @media (min-width: 768px) {
        .cw-cell input {
            font-size: 1.2rem;
        }
    }
    .cw-cell.correct {
        background: #f0fdf4;
        border-color: #10b981;
    }
    .cw-cell.correct input {
        color: #059669;
    }
    .clue-item {
        padding: 8px 12px;
        border-radius: 10px;
        transition: all 0.2s;
        cursor: pointer;
    }
    .clue-item:hover {
        background: #f8fafc;
        color: #10b981;
    }
    .custom-scrollbar::-webkit-scrollbar {
        width: 4px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #e2e8f0;
        border-radius: 10px;
    }
</style>

<script>
    import conceptosData from "../../public/conceptos.json";

    (function () {
        const MAX_SIZE = 22;
        let currentLimit = 10;
        let grid = [];
        let words = [];
        let startTime = null;
        let timerInterval = null;

        const gridE = document.getElementById("crossword-grid");
        const acrossE = document.getElementById("clues-across");
        const downE = document.getElementById("clues-down");
        const resetB = document.getElementById("reset-crossword");
        const timerE = document.getElementById("timer-badge-cw");
        const modalE = document.getElementById("victory-modal-cw");
        const finishTimeE = document.getElementById("finish-time-cw");
        const closeModalB = document.getElementById("close-modal-cw");
        const countSelectors = document.querySelectorAll(
            "#word-count-selector button",
        );
        const tooltipE = document.getElementById("cw-tooltip");

        function init() {
            clearInterval(timerInterval);
            startTime = null;
            if (timerE) timerE.textContent = "00:00";
            if (gridE) gridE.innerHTML = "";
            if (acrossE) acrossE.innerHTML = "";
            if (downE) downE.innerHTML = "";
            if (gridE) gridE.appendChild(tooltipE); // Move it back in case it's gone

            if (modalE) {
                modalE.classList.add("pointer-events-none");
                modalE.classList.remove("opacity-100");
                modalE.querySelector("div")?.classList.add("scale-90");
            }

            countSelectors.forEach((btn) => {
                (btn as HTMLElement).dataset.active = (
                    parseInt((btn as HTMLElement).dataset.count!) ===
                    currentLimit
                ).toString();
            });

            const pool = conceptosData
                .map((c) => ({
                    word: c.termino.toUpperCase().replace(/[^A-Z√Å√â√ç√ì√ö√ë]/g, ""),
                    clue: c.definicion,
                }))
                .filter((w) => w.word.length >= 3 && w.word.length <= 12)
                .sort(() => 0.5 - Math.random());

            generateLayout(pool.slice(0, currentLimit));
            render();
        }

        function generateLayout(pool) {
            grid = Array(MAX_SIZE)
                .fill(null)
                .map(() => Array(MAX_SIZE).fill(null));
            words = [];
            if (pool.length === 0) return;

            const first = pool[0];
            const r = Math.floor(MAX_SIZE / 2);
            const c = Math.floor((MAX_SIZE - first.word.length) / 2);
            placeWord(first, r, c, "H", 1);

            for (let i = 1; i < pool.length; i++) {
                let bestMatch = null;
                const newWord = pool[i].word;

                for (let existing of words) {
                    for (let j = 0; j < existing.word.length; j++) {
                        for (let k = 0; k < newWord.length; k++) {
                            if (existing.word[j] === newWord[k]) {
                                const newDir = existing.dir === "H" ? "V" : "H";
                                const newR =
                                    existing.dir === "H"
                                        ? existing.r - k
                                        : existing.r + j;
                                const newC =
                                    existing.dir === "H"
                                        ? existing.c + j
                                        : existing.c - k;

                                if (canPlace(newWord, newR, newC, newDir)) {
                                    bestMatch = {
                                        r: newR,
                                        c: newC,
                                        dir: newDir,
                                    };
                                    break;
                                }
                            }
                        }
                        if (bestMatch) break;
                    }
                    if (bestMatch) break;
                }

                if (bestMatch) {
                    placeWord(
                        pool[i],
                        bestMatch.r,
                        bestMatch.c,
                        bestMatch.dir,
                        i + 1,
                    );
                }
            }
        }

        function canPlace(word, r, c, dir) {
            if (r < 1 || r >= MAX_SIZE - 1 || c < 1 || c >= MAX_SIZE - 1)
                return false;
            if (dir === "H" && c + word.length >= MAX_SIZE - 1) return false;
            if (dir === "V" && r + word.length >= MAX_SIZE - 1) return false;

            for (let i = 0; i < word.length; i++) {
                const currR = dir === "H" ? r : r + i;
                const currC = dir === "H" ? c + i : c;
                const existing = grid[currR][currC];

                if (existing && existing.char !== word[i]) return false;

                if (!existing) {
                    if (dir === "H") {
                        if (
                            checkCell(currR - 1, currC) ||
                            checkCell(currR + 1, currC)
                        )
                            return false;
                        if (i === 0 && checkCell(currR, currC - 1))
                            return false;
                        if (
                            i === word.length - 1 &&
                            checkCell(currR, currC + 1)
                        )
                            return false;
                    } else {
                        if (
                            checkCell(currR, currC - 1) ||
                            checkCell(currR, currC + 1)
                        )
                            return false;
                        if (i === 0 && checkCell(currR - 1, currC))
                            return false;
                        if (
                            i === word.length - 1 &&
                            checkCell(currR + 1, currC)
                        )
                            return false;
                    }
                }
            }
            return true;
        }

        function checkCell(r, c) {
            if (r < 0 || r >= MAX_SIZE || c < 0 || c >= MAX_SIZE) return false;
            return grid[r][c] !== null;
        }

        function placeWord(p, r, c, dir, num) {
            for (let i = 0; i < p.word.length; i++) {
                const currR = dir === "H" ? r : r + i;
                const currC = dir === "H" ? c + i : c;
                if (!grid[currR][currC]) {
                    grid[currR][currC] = {
                        char: p.word[i],
                        num: i === 0 ? num : null,
                        words: [num],
                    };
                } else {
                    if (i === 0) grid[currR][currC].num = num;
                    grid[currR][currC].words.push(num);
                }
            }
            words.push({ ...p, r, c, dir, num });
        }

        function render() {
            if (!gridE) return;
            let minR = MAX_SIZE,
                maxR = 0,
                minC = MAX_SIZE,
                maxC = 0;
            grid.forEach((row, r) =>
                row.forEach((cell, c) => {
                    if (cell) {
                        minR = Math.min(minR, r);
                        maxR = Math.max(maxR, r);
                        minC = Math.min(minC, c);
                        maxC = Math.max(maxC, c);
                    }
                }),
            );

            const cols = maxC - minC + 5; // "Al menos una m√°s" -> added 2 more on each side (min-2, max+2)
            gridE.style.gridTemplateColumns = `repeat(${cols}, minmax(30px, 45px))`;

            for (let r = minR - 2; r <= maxR + 2; r++) {
                for (let c = minC - 2; c <= maxC + 2; c++) {
                    const cellEl = document.createElement("div");
                    cellEl.className = "cw-cell";
                    const data =
                        r >= 0 && r < MAX_SIZE && c >= 0 && c < MAX_SIZE
                            ? grid[r][c]
                            : null;

                    if (data) {
                        cellEl.classList.add("active");
                        if (data.num) {
                            const n = document.createElement("span");
                            n.className = "num";
                            n.textContent = data.num;
                            cellEl.appendChild(n);
                        }
                        const input = document.createElement("input");
                        input.maxLength = 1;
                        input.dataset.r = r.toString();
                        input.dataset.c = c.toString();

                        input.onfocus = () => {
                            if (!startTime) startTimer();
                            cellEl.classList.add("focused");
                            showTooltip(input, data);
                        };
                        input.onblur = () => {
                            cellEl.classList.remove("focused");
                            hideTooltip();
                        };
                        input.oninput = () => {
                            if (input.value.toUpperCase() === data.char) {
                                cellEl.classList.add("correct");
                                checkWin();
                                // Auto advance in the current word's direction
                                const wordIdx = data.words[0];
                                const wordData = words.find(
                                    (w) => w.num === wordIdx,
                                );
                                if (wordData) {
                                    if (wordData.dir === "H")
                                        moveInDirection(r, c, 0, 1);
                                    else moveInDirection(r, c, 1, 0);
                                }
                            } else {
                                cellEl.classList.remove("correct");
                            }
                        };
                        input.onkeydown = (e) => {
                            if (e.key === "ArrowRight")
                                moveInDirection(r, c, 0, 1);
                            if (e.key === "ArrowLeft")
                                moveInDirection(r, c, 0, -1);
                            if (e.key === "ArrowDown")
                                moveInDirection(r, c, 1, 0);
                            if (e.key === "ArrowUp")
                                moveInDirection(r, c, -1, 0);
                            if (e.key === "Backspace" && !input.value) {
                                // For now just simple backspace logic is handled by browser
                            }
                        };
                        cellEl.appendChild(input);
                    }
                    gridE.appendChild(cellEl);
                }
            }

            words.forEach((w) => {
                const li = document.createElement("li");
                li.className = "clue-item";
                li.innerHTML = `<span class="font-black text-emerald-500 mr-2">${w.num}.</span> ${w.clue}`;
                li.onclick = () => {
                    const input = gridE.querySelector(
                        `input[data-r="${w.r}"][data-c="${w.c}"]`,
                    ) as HTMLInputElement;
                    input?.focus();
                };
                if (w.dir === "H") acrossE?.appendChild(li);
                else downE?.appendChild(li);
            });
        }

        function showTooltip(input: HTMLInputElement, data: any) {
            if (!tooltipE) return;
            const wordIdx = data.words[0];
            const wordData = words.find((w) => w.num === wordIdx);
            if (!wordData) return;

            tooltipE.innerHTML = `
                <div class="mb-1 text-slate-400 font-black uppercase text-[9px] tracking-widest">${wordData.dir === "H" ? "Horizontal" : "Vertical"} ${wordData.num}</div>
                <div>${wordData.clue}</div>
                <div class="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-full w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-t-[6px] border-t-slate-900"></div>
            `;

            tooltipE.classList.remove("opacity-0");
            tooltipE.classList.add("opacity-100");

            const rect = input.getBoundingClientRect();
            const gridRect = gridE?.getBoundingClientRect();
            if (gridRect) {
                tooltipE.style.left = `${rect.left - gridRect.left + rect.width / 2}px`;
                tooltipE.style.top = `${rect.top - gridRect.top - 10}px`;
                tooltipE.style.transform = "translate(-50%, -100%)";
            }
        }

        function hideTooltip() {
            tooltipE?.classList.remove("opacity-100");
            tooltipE?.classList.add("opacity-0");
        }

        function moveInDirection(r, c, dr, dc) {
            const next = gridE?.querySelector(
                `input[data-r="${r + dr}"][data-c="${c + dc}"]`,
            ) as HTMLInputElement;
            next?.focus();
        }

        function startTimer() {
            if (timerInterval) return;
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const m = String(Math.floor(elapsed / 60)).padStart(2, "0");
                const s = String(elapsed % 60).padStart(2, "0");
                if (timerE) timerE.textContent = `${m}:${s}`;
            }, 1000);
        }

        function checkWin() {
            if (!gridE) return;
            const total = gridE.querySelectorAll("input").length;
            const correct = gridE.querySelectorAll(".cw-cell.correct").length;
            if (total > 0 && total === correct) {
                clearInterval(timerInterval!);
                if (finishTimeE && timerE)
                    finishTimeE.textContent = timerE.textContent;
                if (modalE) {
                    modalE.classList.remove("pointer-events-none");
                    modalE.classList.add("opacity-100");
                    modalE.querySelector("div")?.classList.remove("scale-90");
                }
            }
        }

        countSelectors.forEach((btn) =>
            btn.addEventListener("click", () => {
                currentLimit = parseInt((btn as HTMLElement).dataset.count!);
                init();
            }),
        );

        if (resetB) resetB.onclick = init;
        if (closeModalB) closeModalB.onclick = init;

        init();
    })();
</script>
