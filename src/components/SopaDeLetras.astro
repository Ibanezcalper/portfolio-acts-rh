---
import conceptosData from "../../public/conceptos.json";
---

<div class="max-w-6xl mx-auto px-4 py-12" id="sopa-container">
    <div class="text-center mb-10">
        <h2 class="text-4xl font-black text-blue-900 drop-shadow-sm uppercase">
            Sopa de Letras RH
        </h2>
        <p class="text-gray-500 font-medium">
            Encuentra las 10 palabras clave ocultas en la cuadrícula.
        </p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-12 items-start">
        <!-- Palabra List -->
        <div
            class="lg:col-span-1 bg-white p-6 rounded-3xl shadow-xl border border-blue-50"
        >
            <h3
                class="text-xl font-bold text-gray-800 mb-6 flex items-center gap-2"
            >
                <span class="p-2 bg-blue-100 text-blue-600 rounded-lg">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        class="h-5 w-5"
                        viewBox="0 0 20 20"
                        fill="currentColor"
                    >
                        <path
                            fill-rule="evenodd"
                            d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z"
                            clip-rule="evenodd"></path>
                    </svg>
                </span>
                Lista de Palabras
            </h3>
            <ul id="word-list" class="space-y-3">
                <!-- JS populated -->
            </ul>
            <div class="mt-8 pt-6 border-t border-gray-100">
                <button
                    id="reset-game"
                    class="w-full py-4 bg-gray-900 text-white rounded-2xl font-bold transition-all hover:bg-black active:scale-95 flex justify-center items-center gap-2"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        class="h-5 w-5"
                        viewBox="0 0 20 20"
                        fill="currentColor"
                    >
                        <path
                            fill-rule="evenodd"
                            d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61 5.002 5.002 0 008.715 1.333H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z"
                            clip-rule="evenodd"></path>
                    </svg>
                    Generar New Sopa
                </button>
            </div>
        </div>

        <!-- Sopa Grid -->
        <div class="lg:col-span-2 select-none">
            <div
                id="grid-container"
                class="grid grid-cols-10 md:grid-cols-15 gap-2 bg-blue-50 p-6 rounded-3xl shadow-inner border-4 border-blue-100 min-h-[500px]"
            >
                <!-- JS populated -->
            </div>
        </div>
    </div>
</div>

<style>
    .cell-selected {
        background-color: #3b82f6 !important;
        color: white !important;
        transform: scale(0.9);
        border-radius: 8px;
    }
    .cell-found {
        background-color: #22c55e !important;
        color: white !important;
        border-radius: 8px;
        position: relative;
    }
    .cell-found::after {
        content: "";
        position: absolute;
        inset: 0;
        border: 2px solid white;
        border-radius: 8px;
        opacity: 0.3;
    }

    .grid-cell {
        aspect-ratio: 1/1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
        font-size: 1.1rem;
        background: white;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        color: #1e3a8a;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    .grid-cell:hover:not(.cell-found) {
        background-color: #dbeafe;
        transform: translateY(-2px);
    }
</style>

<script define:vars={{ conceptosData }}>
    const gridSize = 15;
    const wordCount = 10;

    let words = [];
    let grid = [];
    let selectedCells = [];
    let foundWords = [];

    const gridContainer = document.getElementById("grid-container");
    const wordListEl = document.getElementById("word-list");
    const resetBtn = document.getElementById("reset-game");

    function initGame() {
        // Clear old
        gridContainer.innerHTML = "";
        wordListEl.innerHTML = "";
        selectedCells = [];
        foundWords = [];
        grid = Array(gridSize)
            .fill(null)
            .map(() => Array(gridSize).fill(""));

        // Pick 10 random terms, and clean them (no spaces, no special chars, max length 12)
        const candidates = conceptosData
            .map((c) => c.termino.toUpperCase().replace(/[^A-Z]/g, ""))
            .filter((t) => t.length > 2 && t.length < 13);

        // Shuffle candidates
        const shuffled = candidates.sort(() => 0.5 - Math.random());
        words = [...new Set(shuffled)].slice(0, wordCount);

        // Place words
        words.forEach((word) => {
            let placed = false;
            while (!placed) {
                const direction = Math.floor(Math.random() * 3); // 0: H, 1: V, 2: D
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);

                if (canPlace(word, row, col, direction)) {
                    placeWord(word, row, col, direction);
                    placed = true;
                }
            }
        });

        // Fill empty
        const alphabet = "ABCDEFGHIJKLMNÑOPQRSTUVWXYZ";
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                if (grid[r][c] === "") {
                    grid[r][c] =
                        alphabet[Math.floor(Math.random() * alphabet.length)];
                }
            }
        }

        // Render
        renderGrid();
        renderWordList();
    }

    function canPlace(word, row, col, dir) {
        if (dir === 0) {
            // H
            if (col + word.length > gridSize) return false;
            for (let i = 0; i < word.length; i++) {
                if (grid[row][col + i] !== "" && grid[row][col + i] !== word[i])
                    return false;
            }
        } else if (dir === 1) {
            // V
            if (row + word.length > gridSize) return false;
            for (let i = 0; i < word.length; i++) {
                if (grid[row + i][col] !== "" && grid[row + i][col] !== word[i])
                    return false;
            }
        } else {
            // D
            if (row + word.length > gridSize || col + word.length > gridSize)
                return false;
            for (let i = 0; i < word.length; i++) {
                if (
                    grid[row + i][col + i] !== "" &&
                    grid[row + i][col + i] !== word[i]
                )
                    return false;
            }
        }
        return true;
    }

    function placeWord(word, row, col, dir) {
        for (let i = 0; i < word.length; i++) {
            if (dir === 0) grid[row][col + i] = word[i];
            else if (dir === 1) grid[row + i][col] = word[i];
            else grid[row + i][col + i] = word[i];
        }
    }

    function renderGrid() {
        gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, minmax(0, 1fr))`;
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const cell = document.createElement("div");
                cell.classList.add("grid-cell");
                cell.innerText = grid[r][c];
                cell.dataset.row = r.toString();
                cell.dataset.col = c.toString();

                cell.addEventListener("mousedown", () =>
                    startSelection(r, c, cell),
                );
                cell.addEventListener("mouseenter", () =>
                    continueSelection(r, c, cell),
                );
                gridContainer.appendChild(cell);
            }
        }
        window.addEventListener("mouseup", endSelection);
    }

    function renderWordList() {
        words.forEach((word) => {
            const li = document.createElement("li");
            li.classList.add(
                "flex",
                "items-center",
                "gap-3",
                "text-gray-600",
                "font-semibold",
                "transition-all",
            );
            li.id = `list-${word}`;
            li.innerHTML = `
                <div class="w-6 h-6 border-2 border-blue-200 rounded-full flex-shrink-0 flex items-center justify-center">
                    <div class="w-2 h-2 bg-blue-200 rounded-full hidden"></div>
                </div>
                <span>${word}</span>
            `;
            wordListEl.appendChild(li);
        });
    }

    let isSelecting = false;
    let startCell = null;

    function startSelection(r, c, el) {
        isSelecting = true;
        startCell = { r, c };
        clearSelection();
        addCellToSelection(r, c, el);
    }

    function continueSelection(r, c, el) {
        if (!isSelecting) return;

        // Logical check for straight lines (H, V, D)
        const dr = r - startCell.r;
        const dc = c - startCell.dc;

        if (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) {
            clearSelection();
            const steps = Math.max(Math.abs(dr), Math.abs(dc));
            const sr = dr === 0 ? 0 : dr / Math.abs(dr);
            const sc = dc === 0 ? 0 : dc / Math.abs(dc);

            for (let i = 0; i <= steps; i++) {
                const tr = startCell.r + i * sr;
                const tc = startCell.c + i * sc;
                const targetEl = document.querySelector(
                    `[data-row="${tr}"][data-col="${tc}"]`,
                );
                if (targetEl) addCellToSelection(tr, tc, targetEl);
            }
        }
    }

    function addCellToSelection(r, c, el) {
        selectedCells.push({ r, c, el });
        el.classList.add("cell-selected");
    }

    function clearSelection() {
        selectedCells.forEach((cell) =>
            cell.el.classList.remove("cell-selected"),
        );
        selectedCells = [];
    }

    function endSelection() {
        if (!isSelecting) return;
        isSelecting = false;

        const selectedWord = selectedCells.map((c) => c.el.innerText).join("");
        const reversedWord = selectedWord.split("").reverse().join("");

        if (
            words.includes(selectedWord) &&
            !foundWords.includes(selectedWord)
        ) {
            markFound(selectedWord, selectedCells);
        } else if (
            words.includes(reversedWord) &&
            !foundWords.includes(reversedWord)
        ) {
            markFound(reversedWord, selectedCells);
        }

        clearSelection();
    }

    function markFound(word, cells) {
        foundWords.push(word);
        cells.forEach((c) => {
            c.el.classList.add("cell-found");
        });

        const listEl = document.getElementById(`list-${word}`);
        if (listEl) {
            listEl.classList.add(
                "text-green-600",
                "line-through",
                "opacity-50",
            );
            listEl.querySelector(".w-2").classList.remove("hidden");
            listEl.querySelector(".w-2").classList.add("bg-green-500");
            listEl
                .querySelector(".border-2")
                .classList.replace("border-blue-200", "border-green-500");
        }

        if (foundWords.length === words.length) {
            setTimeout(
                () => alert("¡Felicidades! Encontraste todas las palabras."),
                200,
            );
        }
    }

    resetBtn.addEventListener("click", initGame);
    initGame();
</script>
